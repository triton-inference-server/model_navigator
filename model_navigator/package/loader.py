# Copyright (c) 2023, NVIDIA CORPORATION. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Load package from file."""

import pathlib
import zipfile
from typing import List, Union

import yaml
from packaging import version

from model_navigator.api.config import Format
from model_navigator.configuration.model.model_config import ModelConfig
from model_navigator.core.logger import LOGGER
from model_navigator.core.tensor import TensorMetadata
from model_navigator.core.workspace import Workspace
from model_navigator.exceptions import ModelNavigatorBackwardCompatibilityError
from model_navigator.frameworks import Framework

from .package import Package
from .status import Status


class PackageLoader:
    """Create package from file."""

    def __init__(self):
        """Initialize loader."""
        self._updater = PackageUpdater()

    def from_file(self, path: Union[str, pathlib.Path], workspace: Workspace) -> Package:
        """Load package from provided path.

        Args:
            path: The location of package to load
            workspace: Workspace where packages will be extracted

        Returns:
            Package.
        """
        path = pathlib.Path(path)

        with zipfile.ZipFile(path, "r") as zf:
            with zf.open(Package.status_filename) as status_file:
                status_dict = yaml.safe_load(status_file)

            package_version = self._extract_package_version(status_dict)
            status = Status.from_dict(status_dict)

            package = Package(status=status, workspace=workspace)
            all_members = zf.namelist()
            filtered_members = self._filter_out_generated_files(all_members)
            zf.extractall(workspace.path, members=filtered_members)

        self._updater.run(package, package_version)

        return package

    def from_workspace(
        self,
        workspace_path: Union[str, pathlib.Path],
    ) -> Package:
        """Load package from provided workspace.

        Args:
            workspace_path: Workspace where packages will be extracted

        Returns:
            Package.
        """
        workspace = Workspace(workspace_path)
        status_path = workspace.path / Package.status_filename
        if not status_path.exists():
            raise FileNotFoundError(f"Status file {status_path} not found.")
        with open(status_path) as status_file:
            status_dict = yaml.safe_load(status_file)
        package_version = self._extract_package_version(status_dict)
        status = Status.from_dict(status_dict)
        package = Package(status=status, workspace=workspace)
        self._updater.run(package, package_version)

        return package

    def _filter_out_generated_files(self, paths: List[str]):
        generated_files_extensions = [".log", ".sh", ".py"]
        return [p for p in paths if not any(p.endswith(suffix) for suffix in generated_files_extensions)]

    def _extract_package_version(self, status_dict):
        return version.parse(status_dict.get("model_navigator_version", "0.3.0"))


class PackageUpdater:
    """Updater the package to the current version.

    Raises:
        ModelNavigatorBackwardCompatibilityError: When the package is no longer supported.
    """

    def __init__(self):
        """Construct PackageUpdater."""
        self._updates = {version.parse("0.3.3"): _update_from_v0_3_3}

    def run(self, package: Package, package_version: version.Version):
        """Update the package to the current version.

        Args:
            package: Package to be updated.
            package_version: Version of the package to be updated.
        """
        for update_from_version, update_func in self._updates.items():
            if package_version <= update_from_version:
                update_func(package)


def _update_from_v0_3_3(package):
    if package.framework != Framework.TENSORFLOW:
        return

    if len(package.status.input_metadata) > 1:
        raise ModelNavigatorBackwardCompatibilityError(
            "Cannot load TensorFlow2 .nav packages generated by Model Navigator "
            "version < 0.3.4 and with multiple inputs."
        )
    model_config = package.status.models_status[Format.TF_SAVEDMODEL.value].model_config
    _update_savedmodel_signature(
        model_config=model_config,
        input_metadata=package.status.input_metadata,
        output_metadata=package.status.output_metadata,
        workspace=package.workspace,
    )


def _update_savedmodel_signature(
    model_config: ModelConfig,
    input_metadata: TensorMetadata,
    output_metadata: TensorMetadata,
    workspace: Workspace,
    verbose: bool = False,
):
    LOGGER.info("Updating SavedModel signature...")
    from model_navigator.commands.export.tf import UpdateSavedModelSignature

    UpdateSavedModelSignature().run(
        path=model_config.path,
        input_metadata=input_metadata,
        output_metadata=output_metadata,
        workspace=workspace,
        verbose=verbose,
    )
